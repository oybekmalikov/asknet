import { Injectable } from "@nestjs/common";
import { InjectModel } from "@nestjs/sequelize";
import { InjectBot } from "nestjs-telegraf";
import { Context, Markup, Telegraf } from "telegraf";
import { BOT_NAME } from "../../app.constants";
import { District } from "../../district/models/district.model";
import { QuestionAnswer } from "../../question_answers/models/question_answer.model";
import { QuestionLogic } from "../../question_logics/models/question_logic.model";
import { Question } from "../../questions/models/question.model";
import { Region } from "../../region/models/region.model";
import { Survey } from "../../surveys/models/survey.model";
import {
	mySurveyButtonsRu,
	mySurveyButtonsUz,
	usersMainButtonsRu,
	usersMainButtonsUz,
} from "../bot.constants";
import { Response } from "../models/responses.model";
import { UserSurvey } from "../models/user_surveys.model";
import { User } from "../models/users.model";

@Injectable()
export class UserService {
	constructor(
		@InjectBot(BOT_NAME) private readonly bot: Telegraf<Context>,
		@InjectModel(User) private readonly userModel: typeof User,
		@InjectModel(UserSurvey)
		private readonly userSurveyModel: typeof UserSurvey,
		@InjectModel(Region) private readonly regionModel: typeof Region,
		@InjectModel(District) private readonly districtModel: typeof District,
		@InjectModel(Response) private readonly responseModel: typeof Response,
		@InjectModel(Survey) private readonly surveyModel: typeof Survey,
		@InjectModel(Question) private readonly questionModel: typeof Question,
		@InjectModel(QuestionAnswer)
		private readonly questionAnswerModel: typeof QuestionAnswer,
		@InjectModel(QuestionLogic)
		private readonly questionLogicModel: typeof QuestionLogic
	) {}
	async throwToStart(ctx: Context) {
		try {
			await ctx.replyWithHTML(
				`üá∫üáø Iltimos, /start tugmasini bosing\nüá∑üá∫ –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É /start.`,
				{
					...Markup.keyboard([["/start"]]).resize(),
				}
			);
		} catch (error) {
			console.log(`Error on throw to start: `, error);
		}
	}

	async start(ctx: Context) {
		try {
			const userId = String(ctx.from?.id);
			const user = await this.userModel.findOne({ where: { userId } });
			if (
				!user ||
				user.last_state == "lang" ||
				user.last_state == "introduction"
			) {
				await this.userModel.create({
					first_name: ctx.from?.first_name,
					last_name: ctx.from?.last_name,
					username: ctx.from?.username,
					last_state: "lang",
					userId,
				});
				await ctx.replyWithHTML(
					"üá∫üáø Assalomu aleykum, kerakli tilni tanlang.\nüá∑üá∫ –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—ã–π —è–∑—ã–∫.",
					{
						reply_markup: {
							inline_keyboard: [
								[
									{
										text: `üá∫üáø O'zbekcha`,
										callback_data: `lang_uz_${userId}`,
									},
									{
										text: `üá∑üá∫ –†—É—Å—Å–∫–∏–π`,
										callback_data: `lang_ru_${userId}`,
									},
								],
							],
						},
					}
				);
			} else if (user.last_state == "name" || user.last_state == "phone") {
				await this.onEnteringName(ctx);
			} else if (user.status || user.last_state == "my_survey") {
				await ctx.replyWithHTML(
					user.language == "uz"
						? `Salom ${user.real_full_name}`
						: `–ü—Ä–∏–≤–µ—Ç ${user.real_full_name}`,
					{
						...Markup.keyboard(
							user.language == "uz" ? usersMainButtonsUz : usersMainButtonsRu
						).resize(),
					}
				);
			}
		} catch (error) {
			console.log("Error on start: ", error);
		}
	}
	async endOfSurvey(ctx: Context, currUser: User, survey: Survey) {
		await this.userSurveyModel.update(
			{ status: true },
			{ where: { userId: currUser.id, surveyId: survey.id } }
		);
		ctx.replyWithHTML(
			currUser.language == "uz"
				? `üéâ Tabriklaymiz <a href="https://t.me/${currUser?.username}">${currUser?.real_full_name}</a>! Siz so'rovnomani muvaffaqiyatli yakunladingiz!\n\nüí∞ So'rovnomani yakunlaganingiz uchun hisobingizga ${survey?.reward_per_participant} so'm qo'shildi\n\nüìÑ Yangi so'rovnomalarni ko'rish uchun ¬´üÜï Yangi So'rovnomalar¬ª ni bosing.`
				: `üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º <a href="https://t.me/${currUser?.username}">${currUser?.real_full_name}</a>! –í—ã —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ—à–ª–∏ –æ–ø—Ä–æ—Å!\n\nüí∞ ${survey?.reward_per_participant} —Å—É–º–æ–≤ –±—ã–ª–∏ –∑–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞ –≤–∞—à —Å—á–µ—Ç –∑–∞ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏–µ –æ–ø—Ä–æ—Å–∞\n\nüìÑ –ß—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –Ω–æ–≤—ã–µ –æ–ø—Ä–æ—Å—ã, –Ω–∞–∂–º–∏—Ç–µ ¬´üÜï –ù–æ–≤—ã–µ –æ–ø—Ä–æ—Å—ã¬ª.`,
			{
				...Markup.keyboard([
					currUser!.language == "uz" ? ["üè† Bosh menu"] : ["üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"],
				]).resize(),
			}
		);
	}
	async onText(ctx: Context) {
		try {
			const userId = String(ctx.from?.id);
			const user = await this.userModel.findOne({ where: { userId } });
			if (!user) {
				await this.throwToStart(ctx);
			} else {
				if ("text" in ctx.message!) {
					const userInput = ctx.message.text;
					if (user.last_state == "name") {
						user.real_full_name = userInput;
						user.last_state = "phone";
						await user.save();
						await ctx.replyWithHTML(
							user.language == "uz"
								? `‚òé Telefon raqamingizni yuboring.`
								: `‚òé –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–≤–æ–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞.`,
							{
								...Markup.keyboard([
									Markup.button.contactRequest(
										user.language == "uz"
											? "üìû Telefon raqamni yuborish"
											: "üìû –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞"
									),
								]).resize(),
							}
						);
					} else if (user.actions.startsWith("survey_")) {
						const [text, surveyId, questionId, logicId, userId] =
							user.actions.split("_");
						const userInput = ctx.message!.text;
						await this.responseModel.create({
							participant_id: user.id,
							question_id: +questionId,
							response: userInput,
							response_time: new Date().toISOString(),
						});
						const logic = await this.questionLogicModel.findOne({
							where: { question_id: +questionId },
						});
						const survey = await this.surveyModel.findOne({
							where: { id: +surveyId },
						});
						if (logic?.status == "end_survey") {
							user.actions = "";
							user.save();
							await this.endOfSurvey(ctx, user, survey!);
							return;
						} else if (
							logic?.status == "skip_to" ||
							logic?.status == "start_survey"
						) {
							const question = await this.questionModel.findOne({
								where: { id: logic.next_question_id },
							});
							if (!question) {
								await this.endOfSurvey(ctx, user, survey!);
								return;
							} else {
								const answers = await this.questionAnswerModel.findAll({
									where: { question_id: question!.id },
									order: [["id", "ASC"]],
								});
								if (!answers.length && question.field_type != "text") {
									await this.endOfSurvey(ctx, user, survey!);
									return;
								} else {
									if (question.field_type == "text") {
										user.actions = `survey_${survey!.id}_${question.id}_${logic!.id}_${user.id}`;
										await user.save();
										await ctx.replyWithHTML(
											user.language == "uz"
												? question.title_uz
												: question.title_ru,
											{ ...Markup.removeKeyboard() }
										);
										return;
									}
									const inline_btns: any = [];
									if (answers[0].count_option == " 1") {
										for (const ans of answers) {
											const temp: any = [];
											temp.push({
												text:
													user.language == "uz"
														? ans.answer_title_uz
														: ans.answer_title_ru,
												callback_data: `survey_${survey!.id}_${question.id}_${logic!.id}_${ans.id}_${user.id}`,
											});
											inline_btns.push(temp);
										}
									} else {
										const temp: any = [];
										for (const ans of answers) {
											temp.push({
												text:
													user.language == "uz"
														? ans.answer_title_uz
														: ans.answer_title_ru,
												callback_data: `survey_${survey!.id}_${question.id}_${logic!.id}_${ans.id}_${user.id}`,
											});
											if (temp.length == 2) {
												inline_btns.push([...temp]);
												temp.length = 0;
											}
										}
										if (temp.length == 1) {
											inline_btns.push([...temp]);
											temp.length = 0;
										}
									}
									await ctx.replyWithHTML(
										user.language == "uz"
											? question.title_uz
											: question.title_ru,
										{
											reply_markup: {
												inline_keyboard: inline_btns,
											},
										}
									);
									return;
								}
							}
						}
					}
				}
			}
		} catch (error) {
			console.log(`Error on user on Text: `, error);
		}
	}
	async onSelectingLang(ctx: Context) {
		try {
			const contextAction = ctx.callbackQuery!["data"];
			const contextMessage = ctx.callbackQuery!["message"];
			const userId = contextAction.split("_")[2];
			const lang = contextAction.split("_")[1];
			ctx.deleteMessage(contextMessage?.message_id);
			await this.userModel.update(
				{ language: lang, last_state: "introduction" },
				{ where: { userId } }
			);
			await ctx.replyWithHTML(
				lang == "uz"
					? `üì¢ Diqqat!
Quyidagi savollarda sizning ma'lumotlaringiz so‚Äòraladi.
üõ°Ô∏è Barcha ma'lumotlar maxfiy saqlanadi va faqat tahliliy maqsadlarda ishlatiladi.
‚ùó Davom etish orqali siz ushbu ma'lumotlarni qayta ishlashga rozilik bildirgan bo‚Äòlasiz.

Agar rozi bo‚Äòlsangiz, ¬´Davom etish¬ª tugmasini bosing.
`
					: `üì¢ –í–Ω–∏–º–∞–Ω–∏–µ!
–°–ª–µ–¥—É—é—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã –∑–∞–ø—Ä–∞—à–∏–≤–∞—é—Ç –≤–∞—à—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é.
üõ°Ô∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω—ã –∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Ü–µ–ª—è—Ö.
‚ùó –ü—Ä–æ–¥–æ–ª–∂–∞—è, –≤—ã –¥–∞–µ—Ç–µ —Å–æ–≥–ª–∞—Å–∏–µ –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É —ç—Ç–∏—Ö –¥–∞–Ω–Ω—ã—Ö.

–ï—Å–ª–∏ –≤—ã —Å–æ–≥–ª–∞—Å–Ω—ã, –Ω–∞–∂–º–∏—Ç–µ ¬´–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å¬ª.`,
				{
					reply_markup: {
						inline_keyboard: [
							[
								{
									text: lang == "uz" ? `Davom etish` : `–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å`,
									callback_data: "usercontinue",
								},
							],
						],
					},
				}
			);
		} catch (error) {
			console.log(`Error on selecting lang: `, error);
		}
	}
	async onEnteringName(ctx: Context) {
		try {
			const userId = String(ctx.from?.id);
			const user = await this.userModel.findOne({ where: { userId } });
			if (!user) {
				await this.throwToStart(ctx);
			} else {
				user.last_state = "name";
				await user.save();
				await ctx.replyWithHTML(
					user.language == `uz`
						? `Ism va familyangizni(ixtiyoriy) kiriting ‚¨áÔ∏è`
						: `–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ–µ –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) ‚¨áÔ∏è`,
					{ ...Markup.removeKeyboard() }
				);
			}
		} catch (error) {
			console.log(`Error on Name entering: `, error);
		}
	}
	async onMySurveys(ctx: Context, lang: string) {
		try {
			await ctx.replyWithHTML(
				lang == "uz"
					? `üë§ Shaxsiy so'rovnomlaringizni to'ldirib bo'lgandan so'ng, siz, umumiy so'rovnomalarda ishtirok eta olasiz üéâ`
					: `üë§ –ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ª–∏—á–Ω—ã—Ö –æ–ø—Ä–æ—Å–æ–≤ –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–∏–Ω—è—Ç—å —É—á–∞—Å—Ç–∏–µ –≤ –æ–±—â–∏—Ö –æ–ø—Ä–æ—Å–∞—Ö üéâ`,
				{
					...Markup.keyboard(
						lang == "uz" ? mySurveyButtonsUz : mySurveyButtonsRu
					).resize(),
				}
			);
		} catch (error) {
			console.log(`Error on user's onMySurveys: `, error);
		}
	}
	async toMainMenu(ctx: Context, lang: string) {
		try {
			await ctx.replyWithHTML(lang == "uz" ? `üìã Menu` : `üìã –ú–µ–Ω—é`, {
				...Markup.keyboard(
					lang == "uz" ? usersMainButtonsUz : usersMainButtonsRu
				).resize(),
			});
		} catch (error) {
			console.log(`Error on user's toMainMenu: `, error);
		}
	}
	async onSurveyAboutMe(ctx: Context, lang: string) {
		try {
		} catch (error) {
			console.log(`Error on `);
		}
	}
	async onStartSurvey(ctx: Context) {
		try {
			const contextAction = ctx.callbackQuery!["data"];
			const contextMessage = ctx.callbackQuery!["message"];
			const userId = contextAction.split("_")[2];
			const surveyId = contextAction.split("_")[1];
			ctx.deleteMessage(contextMessage?.message_id);
			const user = await this.userModel.findOne({ where: { userId } });
			if (!user) {
				await this.throwToStart(ctx);
			} else {
				const survey = await this.surveyModel.findOne({
					where: { id: surveyId },
				});
				if (!survey) {
					await ctx.replyWithHTML(
						user.language == "uz"
							? "So'rovnoma mavjud emas."
							: "–ê–Ω–∫–µ—Ç–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.",
						{
							...Markup.keyboard([
								user.language == "uz" ? ["üè† Bosh menu"] : ["üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"],
							]),
						}
					);
					return;
				} else {
					const questions = await this.questionModel.findAll({
						where: { survey_id: surveyId },
						order: [["id", "ASC"]],
					});
					const logic = await this.questionLogicModel.findOne({
						where: { status: "start_survey", question_id: questions[0].id },
					});
					const questionAnswers = await this.questionAnswerModel.findAll({
						where: { question_id: questions[0].id },
					});
					if (
						(!logic || !questions.length) &&
						questions[0].field_type != "text"
					) {
						await ctx.replyWithHTML(
							user.language == "uz"
								? "So'rovnoma mavjud emas."
								: "–ê–Ω–∫–µ—Ç–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.",
							{
								...Markup.keyboard([
									user.language == "uz" ? ["üè† Bosh menu"] : ["üè† Bosh menu"],
								]).resize(),
							}
						);
						return;
					} else {
						if (questions[0].field_type == "text") {
							user.actions = `survey_${survey.id}_${questions[0].id}_${logic!.id}_${user.id}`;
							await user.save();
							await ctx.replyWithHTML(
								user.language == "uz"
									? questions[0].title_uz
									: questions[0].title_ru,
								{ ...Markup.removeKeyboard() }
							);
							return;
						}
						const inline_btns: any = [];
						if (questionAnswers[0].count_option == " 1") {
							for (const ans of questionAnswers) {
								const temp: any = [];
								temp.push({
									text:
										user.language == "uz"
											? ans.answer_title_uz
											: ans.answer_title_ru,
									callback_data: `survey_${survey.id}_${questions[0].id}_${logic!.id}_${ans.id}_${user.id}`,
								});
								inline_btns.push(temp);
							}
						} else {
							const temp: any = [];
							for (const ans of questionAnswers) {
								temp.push({
									text:
										user.language == "uz"
											? ans.answer_title_uz
											: ans.answer_title_ru,
									callback_data: `survey_${survey.id}_${questions[0].id}_${logic!.id}_${ans.id}_${user.id}`,
								});
								if (temp.length == 2) {
									inline_btns.push([...temp]);
									temp.length = 0;
								}
							}
							if (temp.length == 1) {
								inline_btns.push([...temp]);
								temp.length = 0;
							}
						}
						await ctx.replyWithHTML(
							user.language == "uz"
								? questions[0].title_uz
								: questions[0].title_ru,
							{
								reply_markup: {
									inline_keyboard: inline_btns,
								},
							}
						);
					}
				}
			}
		} catch (error) {
			console.log(`Error on start survey: `, error);
		}
	}
	async onSurvey(ctx: Context) {
		try {
			// survey_${survey.id}_${questions[0].id}_${logic!.id}_${ans.id}_${user.id}
			const contextAction = ctx.callbackQuery!["data"];
			const contextMessage = ctx.callbackQuery!["message"];
			ctx.deleteMessage(contextMessage?.message_id);
			const [text, surveyId, questionId, logicId, answerId, userId] =
				contextAction.split("_");
			const user = await this.userModel.findOne({ where: { id: userId } });
			if (!user) {
				await this.throwToStart(ctx);
				return;
			} else {
				const oldQuestion = await this.questionModel.findOne({
					where: { id: +questionId },
				});
				let userChoise: any;
				if (oldQuestion?.field_type == "region") {
					userChoise = await this.regionModel.findOne({
						where: { id: +answerId },
					});
					await this.responseModel.create({
						participant_id: user.id,
						question_id: +questionId,
						response: (user.language == "uz"
							? userChoise?.name_uz
							: userChoise?.name_ru)!,
						response_time: new Date().toISOString(),
					});
				} else if (oldQuestion?.field_type == "district") {
					userChoise = await this.districtModel.findOne({
						where: { id: +answerId },
					});
					await this.responseModel.create({
						participant_id: user.id,
						question_id: +questionId,
						response: (user.language == "uz"
							? userChoise?.name_uz
							: userChoise?.name_ru)!,
						response_time: new Date().toISOString(),
					});
				} else {
					userChoise = await this.questionAnswerModel.findOne({
						where: { id: +answerId },
					});
					await this.responseModel.create({
						participant_id: user.id,
						question_id: +questionId,
						response: (user.language == "uz"
							? userChoise?.answer_uz
							: userChoise?.answer_ru)!,
						response_time: new Date().toISOString(),
					});
				}
				const logic = await this.questionLogicModel.findOne({
					where: { question_id: +questionId },
				});
				const survey = await this.surveyModel.findOne({
					where: { id: +surveyId },
				});
				if (logic?.status == "end_survey") {
					user.actions = "";
					user.save();
					await this.endOfSurvey(ctx, user, survey!);
					return;
				} else if (
					logic?.status == "skip_to" ||
					logic?.status == "start_survey"
				) {
					const question = await this.questionModel.findOne({
						where: { id: logic.next_question_id },
					});
					if (!question) {
						await this.endOfSurvey(ctx, user, survey!);
						return;
					} else {
						const answers = await this.questionAnswerModel.findAll({
							where: { question_id: question!.id },
							order: [["id", "ASC"]],
						});
						if (!answers.length && question.field_type == "region") {
							const regions = await this.regionModel.findAll();
							const regionbtn: any = [];
							const temp: any = [];
							for (const ans of regions) {
								temp.push({
									text: user.language == "uz" ? ans.name_uz : ans.name_ru,
									callback_data: `survey_${survey!.id}_${question.id}_${logic!.id}_${ans.id}_${user.id}`,
								});
								if (temp.length == 2) {
									regionbtn.push([...temp]);
									temp.length = 0;
								}
							}
							if (temp.length == 1) {
								regionbtn.push([...temp]);
								temp.length = 0;
							}
							await ctx.replyWithHTML(
								user.language == "uz" ? question.title_uz : question.title_ru,
								{
									reply_markup: {
										inline_keyboard: regionbtn,
									},
								}
							);
							return;
						} else if (!answers.length && question.field_type == "district") {
							const districts = await this.districtModel.findAll({
								where: { region_id: +answerId },
							});
							const districtbtn: any = [];
							const temp: any = [];
							for (const ans of districts) {
								temp.push({
									text: user.language == "uz" ? ans.name_uz : ans.name_ru,
									callback_data: `survey_${survey!.id}_${question.id}_${logic!.id}_${ans.id}_${user.id}`,
								});
								if (temp.length == 2) {
									districtbtn.push([...temp]);
									temp.length = 0;
								}
							}
							if (temp.length == 1) {
								districtbtn.push([...temp]);
								temp.length = 0;
							}
							await ctx.replyWithHTML(
								user.language == "uz" ? question.title_uz : question.title_ru,
								{
									reply_markup: {
										inline_keyboard: districtbtn,
									},
								}
							);
							return;
						}
						if (!answers.length && question.field_type != "text") {
							await this.endOfSurvey(ctx, user, survey!);
							return;
						} else {
							if (question.field_type == "text") {
								user.actions = `survey_${survey!.id}_${question.id}_${logic!.id}_${user.id}`;
								await user.save();
								await ctx.replyWithHTML(
									user.language == "uz" ? question.title_uz : question.title_ru,
									{ ...Markup.removeKeyboard() }
								);
								return;
							}
							const inline_btns: any = [];
							if (answers[0].count_option == " 1") {
								for (const ans of answers) {
									const temp: any = [];
									temp.push({
										text:
											user.language == "uz"
												? ans.answer_title_uz
												: ans.answer_title_ru,
										callback_data: `survey_${survey!.id}_${question.id}_${logic!.id}_${ans.id}_${user.id}`,
									});
									inline_btns.push(temp);
								}
							} else {
								const temp: any = [];
								for (const ans of answers) {
									temp.push({
										text:
											user.language == "uz"
												? ans.answer_title_uz
												: ans.answer_title_ru,
										callback_data: `survey_${survey!.id}_${question.id}_${logic!.id}_${ans.id}_${user.id}`,
									});
									if (temp.length == 2) {
										inline_btns.push([...temp]);
										temp.length = 0;
									}
								}
								if (temp.length == 1) {
									inline_btns.push([...temp]);
									temp.length = 0;
								}
							}
							await ctx.replyWithHTML(
								user.language == "uz" ? question.title_uz : question.title_ru,
								{
									reply_markup: {
										inline_keyboard: inline_btns,
									},
								}
							);
							return;
						}
					}
				}
			}
		} catch (error) {
			console.log(`Error during survey: `, error);
		}
	}
}
